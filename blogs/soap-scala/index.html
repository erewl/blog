<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/blog/styles.0a659684bc790912341a.css" data-identity="gatsby-global-css">.menubar{top:0;width:100%;z-index:1000}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;box-sizing:border-box;font:112.5%/1.45em georgia,serif,sans-serif;overflow-y:scroll}body{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;word-wrap:break-word;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt";color:rgba(0,0,0,.8);font-family:georgia,serif;font-kerning:normal;font-weight:400;margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{-webkit-text-decoration-skip:objects;background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help;text-decoration:none}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{text-rendering:optimizeLegibility;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:2.25rem;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none;margin:0 0 1.45rem;max-width:100%;padding:0}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:0 0 1.45rem;padding:0}hr{background:rgba(0,0,0,.2);border:none;box-sizing:content-box;height:1px;margin:0 0 calc(1.45rem - 1px);overflow:visible;padding:0}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 0 1.45rem;padding:0}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}*,:after,:before{box-sizing:inherit}h2{font-size:1.62671rem}h2,h3{text-rendering:optimizeLegibility;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0}h3{font-size:1.38316rem}h4{font-size:1rem}h4,h5{text-rendering:optimizeLegibility;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;line-height:1.1;margin:0 0 1.45rem;padding:0}h5{font-size:.85028rem}h6{text-rendering:optimizeLegibility;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-size:.78405rem;font-weight:700;line-height:1.1}h6,hgroup{margin:0 0 1.45rem;padding:0}ol,ul{list-style-image:none;list-style-position:outside;margin:0 0 1.45rem 1.45rem;padding:0}dd,dl,p{padding:0}dd,dl,p,pre{margin:0 0 1.45rem}pre{word-wrap:normal;background:rgba(0,0,0,.04);border-radius:3px;font-size:.85rem;line-height:1.42;overflow:auto;padding:1.45rem}table{border-collapse:collapse;font-size:1rem;line-height:1.45rem;margin:0 0 1.45rem;padding:0;width:100%}blockquote{margin:0 1.45rem 1.45rem;padding:0}address,form,iframe,noscript{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-bottom:.725rem;margin-left:1.45rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}td,th,thead{text-align:left}td,th{font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";border-bottom:1px solid rgba(0,0,0,.12);padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{content:" ";letter-spacing:-.2em}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}.menu{color:#fff}</style><meta name="generator" content="Gatsby 3.13.0"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><link rel="icon" href="/blog/favicon-32x32.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a" type="image/png"/><link rel="manifest" href="/blog/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/blog/icons/icon-48x48.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="72x72" href="/blog/icons/icon-72x72.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="96x96" href="/blog/icons/icon-96x96.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="144x144" href="/blog/icons/icon-144x144.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="192x192" href="/blog/icons/icon-192x192.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="256x256" href="/blog/icons/icon-256x256.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="384x384" href="/blog/icons/icon-384x384.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><link rel="apple-touch-icon" sizes="512x512" href="/blog/icons/icon-512x512.png?v=e8fd0ccb690157a6b0a54bb63a6bfb8a"/><title data-react-helmet="true">Your Blog Name - Signing and verfiying SOAP messages with wss4j and Scala</title><link as="script" rel="preload" href="/blog/webpack-runtime-c2cbaca12af7750641c8.js"/><link as="script" rel="preload" href="/blog/framework-dbb71ad78d33dc3746f8.js"/><link as="script" rel="preload" href="/blog/app-5a3b9f28dce8d9576e87.js"/><link as="script" rel="preload" href="/blog/commons-f5cb3665821437b6632f.js"/><link as="script" rel="preload" href="/blog/d6b98378c7c9fb883b2e4a693ed9d6d5ccb6f59a-6da77f1d98d40fd3e3b1.js"/><link as="script" rel="preload" href="/blog/component---src-templates-blogpost-js-e6c6f3700da185d46b96.js"/><link as="fetch" rel="preload" href="/blog/page-data/blogs/soap-scala/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/sq/d/3649515864.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="blog-post-container"><div class="menubar"><header style="background:rebeccapurple;margin-bottom:1.45rem"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem"><h1 style="margin:0"><a style="color:white;text-decoration:none" href="/blog/">erewl&#x27;s blog</a></h1><a class="menu" href="/blog/">Back home</a><a class="menu" href="/blog/blogs">Blogs</a><a class="menu" href="/blog/miniblogs">Mini-Blogs</a></div></header><div style="margin:0 auto;max-width:960px;padding:0 1.0875rem 1.45rem"></div></div><section class="jsx-42076441 "><main class="jsx-1899865532 "><div class="blog-post"><h1>Signing and verfiying SOAP messages with wss4j and Scala</h1><span class="jsx-2983294219 ">soap</span><span class="jsx-2983294219 ">xml</span><span class="jsx-2983294219 ">scala</span><span class="jsx-2983294219 ">wss4j</span><div class="blog-post-content"><h1>Signing and verfiying SOAP messages with wss4j and Scala</h1>
<p>SOAP is not dead. It is an established, XML-based and mature messaging protocol that comes with built-in security mechanisms, integrity checks, content validation and much more. A lot of enterprises and corporations are using it <del>sadly</del> still.
Just recently, Vandebron had to implement a SOAP client to communicate with an external party.
This blog post will explain with code examples how we at Vandebron are signing and verifying SOAP messages for our latest SOAP client implementation.</p>
<p>For this process, we are using Apache's Web Service Security Library <a href="https://ws.apache.org/wss4j/">wss4j</a> as it is a proven tool in the WSS context and provides, as a Java library, great interoperability with the programming language Scala.</p>
<h2>Signing SOAP messages</h2>
<p>Here we will take a look at the necessary steps to sign a SOAP message like this one:</p>
<pre><code class="language-xml">&#x3C;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  &#x3C;soapenv:Header/>
  &#x3C;soapenv:Body>
    &#x3C;heading>Hello World&#x3C;/heading>
    &#x3C;body>I am just a test&#x3C;/body>
  &#x3C;/soapenv:Body>
&#x3C;/soapenv:Envelope>
</code></pre>
<p>To look after signing like this:</p>
<pre><code class="language-xml">&#x3C;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
  &#x3C;soapenv:Header>
    &#x3C;wsse:Security 
    soapenv:mustUnderstand="1" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsse="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd">
      &#x3C;ds:Signature 
      Id="SIG-ec946953-2470-4689-ad2f-0c579e1e06e3" xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
        &#x3C;ds:SignedInfo>
          &#x3C;ds:CanonicalizationMethod Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#">
            &#x3C;ec:InclusiveNamespaces PrefixList="soapenv" xmlns:ec="http://www.w3.org/2001/10/xml-exc-c14n#"/>
          &#x3C;/ds:CanonicalizationMethod>
          &#x3C;ds:SignatureMethod Algorithm="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"/>
          &#x3C;ds:Reference URI="#id-47817454-f6e2-470c-9109-870e7895e3e0">
            &#x3C;ds:Transforms>
              &#x3C;ds:Transform Algorithm="http://www.w3.org/2001/10/xml-exc-c14n#"/>
            &#x3C;/ds:Transforms>
            &#x3C;ds:DigestMethod Algorithm="http://www.w3.org/2001/04/xmlenc#sha256"/>
            &#x3C;ds:DigestValue>7KfPcTwDYWtLj4ZVWmWmVqX4IGwbBAAmUPigCdXdk4U=&#x3C;/ds:DigestValue>
          &#x3C;/ds:Reference>
        &#x3C;/ds:SignedInfo>
        &#x3C;ds:SignatureValue>
          OBnbBWv8S70xDDn5uG++7cTRFa2Uz3D47oxTHuO163Y3/V7H35M1GHXbKaUDOHsgsfx3SdVmVi++ra06cpwJknzqoIQgDV9Qc0ydzfxljCqupPKBnfONDYJtihEE1jtQ0RP7OLzPVNUpgOgHqbLwJu2pRUA05ool+lxIs924OwPVPKyUryoYwWhwY1ttY4P+WY2L3ZqsH3fgoLCyjlvhDEAhsP9PCxsEzPSq3ECC55Nh7nqMoHPj2uNxonuMlPeYbrlMnwyiqEW8s3Sc+WmfiIOgekRE1AdNhpn3ARlO490nObQtXCU/TxeTfbh98TMbQRZWWyT4HuLS3fF6aeyD/Q==
        &#x3C;/ds:SignatureValue>
        &#x3C;ds:KeyInfo Id="KI-e18395de-9a26-4cad-9501-7c6cf6c7c74a">
          &#x3C;wsse:SecurityTokenReference wsu:Id="STR-daa47836-f1f9-4d71-95cc-b7bcc6051c84">
            &#x3C;wsse:KeyIdentifier 
            ValueType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509SubjectKeyIdentifier" EncodingType="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary">
              ox4ajWTdigy9oApTYs97CuCV/4k=
            &#x3C;/wsse:KeyIdentifier>
          &#x3C;/wsse:SecurityTokenReference>
        &#x3C;/ds:KeyInfo>
      &#x3C;/ds:Signature>
    &#x3C;/wsse:Security>
  &#x3C;/soapenv:Header>
  &#x3C;soapenv:Body 
    wsu:Id="id-47817454-f6e2-470c-9109-870e7895e3e0" xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd">
      &#x3C;heading>Hello World&#x3C;/heading>
      &#x3C;body>I am just a test&#x3C;/body>
  &#x3C;/soapenv:Body>
&#x3C;/soapenv:Envelope>
</code></pre>
<p>For implementing the steps of the blog post you will need:</p>
<ul>
<li>a SOAP service you want to send messages to</li>
<li>documentation of that SOAP service that describes:
<ul>
<li>signature algorithm</li>
<li>canonicalization method</li>
<li>digest algorithm</li>
<li>key identifier type</li>
</ul>
</li>
<li>a private key with which you will sign your messages</li>
<li>a certificate that is the counterpart of the private key</li>
<li>(optional) a pool of trusted certificates</li>
</ul>
<p>Our private and public key pair are available in the PKCS#12-format (.p12 file extension). Check out <a href="https://www.ssl.com/how-to/create-a-pfx-p12-certificate-file-using-openssl/">this</a> to learn more about this format and how to achieve it.
The pool of trusted certificates are in the <a href="https://www.ssl.com/guide/pem-der-crt-and-cer-x-509-encodings-and-conversions/">PKCS#7 format</a> (.p7b file extension).</p>
<p>First we have to setup the necessary dependencies:</p>
<pre><code class="language-scala">   // in your build.sbt or project/Dependencies.scala
  // enabling signing and signature verification for SOAP messages
  lazy val webServiceSecurity = Seq(
    "org.apache.wss4j" % "wss4j"                    % "2.3.1" pomOnly (),
    "org.apache.wss4j" % "wss4j-ws-security-dom"    % "2.3.1",
    "org.apache.wss4j" % "wss4j-ws-security-common" % "2.3.1"
  )

  libraryDependencies ++= webServiceSecurity
</code></pre>
<p>Next, we continue with a scala representation of our certificate we are using for signing:</p>
<pre><code class="language-scala">  import org.apache.wss4j.dom.WSConstants
  
  // algorithm configuration
  object SigningCertificate {
    val CanonicalizationMethodURI: String = "http://www.w3.org/2001/10/xml-exc-c14n#"
    val DigestAlgorithmURI: String        = DigestMethod.SHA256
    val SignatureAlgorithmURI: String     = "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
    val KeyIdentifierType: Int             = WSConstants.SKI_KEY_IDENTIFIER
  }

  case class SigningCertificate(keyStore: KeyStore, password: String) {
    require(
      keyStore.aliases().asScala.size == 1,
      s"Certificate of Keystore needs to have one alias but had ${keyStore.aliases().asScala.size}"
    )
    val alias: String = keyStore.aliases().nextElement()

    override def toString: String = s"SigningCertificate(alias=$alias)"
  }
</code></pre>
<p>In the documentation of the SOAP service that you want to call should stand some information regarding the canonicalization method, signature algorithm, digest algorithm, and the key identifier type. Those are algorithms and information that define the signing process and we explain roughly now.</p>
<p>Before signing a message it has to be canonicalized. "Canonicalization is a method for generating a physical representation, the canonical form, of an XML document that accounts for syntactic changes permitted by the XML specification" (from <a href="https://www.di-mgt.com.au/xmldsig-c14n.html">here</a>). In our case, the Exclusive XML Canonicalization is used.</p>
<p>The digest algorithm is used to ensure the integrity of the message during the verification of a signature. The algorithm is used to calculate a hash of the signed message. It should be documented in the SOAP service documentation. Here we will use SHA256 as a hashing algorithm.</p>
<p>The signature algorithm describes how the message will be signed. It can be defined in the SOAP service documentation but in the worst case you can read this algorithm from the certificate itself by using <a href="https://docs.oracle.com/en/java/javase/12/tools/keytool.html"><code>keytool</code></a>:</p>
<pre><code>$ keytool -list -v -keystore signature.p12
Enter keystore password: ...

[...] # more information about the certificates

Signature algorithm name: SHA256withRSA # thats what we are after!

[...] # more information about the certificates
</code></pre>
<p>According to the keytool inspection we will use SHA256withRSA (<a href="http://www.w3.org/2001/04/xmldsig-more#rsa-sha256">http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</a>) for signing.</p>
<p>Last but not least, in our signature, a <code>&#x3C;KeyInfo></code> element is included. This element contains information about the public key of the sender (us) and is needed for the signature verification once the message is received (read more <a href="https://www.xml.com/pub/a/2001/08/08/xmldsig.html">here</a>). Since we have our public key provided we don't need to do much here. The <code>KeyIdentifierType</code> describes which form of key identifier is used to present the public key information.</p>
<p>Having all this information about our certificate in place, we build the mechanism to load in our signing certificate. For this, we create the object <code>KeyStoreBuilder</code>.</p>
<pre><code class="language-scala">import java.io.{File, FileInputStream}

object KeyStoreBuilder {

  def loadSigningCertificate(signingCertificate: File, password: String): SigningCertificate = {
    val fis = new FileInputStream(signingCertificate)
    val ks: KeyStore               = KeyStore.getInstance("PKCS12")
    ks.load(fis, password.toCharArray)
    SigningCertificate(ks, password)
  } 
}
</code></pre>
<p>Bear in mind, that you probably <strong>don't</strong> want to version any sensitive information like private keys and passwords hard-coded or in any environment variables, so a safe mechanism for storing/fetching passwords and certificates (like <a href="https://www.hashicorp.com/products/vault">Vault</a>) should be in place.</p>
<p>With the signing certificate in place, we can actually start signing a message. The next code example contains quite some Java boilerplate from wss4j that is required to make the signing mechanism work.</p>
<p>To restrict the usage of Java classes to a small portion of our code we will firstly implement a conversion method <code>.toElem</code> inside of the companion object <code>SigningService</code>:</p>
<pre><code class="language-scala">  import java.io.StringWriter
  import javax.xml.transform.{OutputKeys, TransformerFactory}
  import javax.xml.transform.dom.DOMSource
  import javax.xml.transform.stream.StreamResult

  import org.w3c.dom.Document

  import scala.xml.Elem

  object SigningService {
    implicit class RichDocument(document: Document) {
      private val tf = TransformerFactory.newInstance()

      def toElem: Elem =
        val transformer = tf.newTransformer()
        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
        val stringWriter = new StringWriter()
        transformer.transform(new DOMSource(document), new StreamResult(stringWriter))
        scala.xml.XML.loadString(stringWriter.getBuffer.toString)
    }
  }
</code></pre>
<p>With that, we can convert any <code>Document</code> SOAP message representation back to the <code>scala.xml</code> supported  <code>Elem</code> format.</p>
<pre><code class="language-scala">class SigningService(signingCertificate: SigningCertificate) {

  // importing our conversion method
  import SigningService.RichDocument

  /**
    * REQUIRED, otherwise it will throw:
    *
    * org.apache.wss4j.common.ext.WSSecurityException:
    * You must initialize the xml-security library correctly before you use it.
    * Call the static method "org.apache.xml.security.Init.init();"
    * to do that before you use any functionality from that library
    */
  org.apache.xml.security.Init.init()
  
  private val documentBuilderFactory = DocumentBuilderFactory.newInstance()
  private val crypto: Merlin = getCrypto

  crypto.setKeyStore(signingCertificate.keyStore)

  def signElement(elem: Elem): Elem = {
    documentBuilderFactory.setNamespaceAware(true)
    // converting Elem to Document (Scala to Java conversion)
    val doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(elem.toString())))

    // WSSecHeader wraps around the document we want to sign
    val header = new WSSecHeader(doc)
    header.setMustUnderstand(true)
    header.insertSecurityHeader()

    // start building Signature, use the (wrapper) header-instance
    val builder = new WSSecSignature(header)
    builder.setUserInfo(signingCertificate.alias, signingCertificate.password)

    // setting algorithms
    builder.setSignatureAlgorithm(SigningCertificate.SignatureAlgorithmURI)
    builder.setSigCanonicalization(SigningCertificate.CanonicalizationMethodURI)
    builder.setDigestAlgo(SigningCertificate.DigestAlgorithmURI)
    builder.setKeyIdentifierType(SigningCertificate.KeyIdentifierType)
    builder.setAddInclusivePrefixes(true)

    // signing the document!
    val signedDocument = builder.build(crypto)
    // conversion back to Elem
    signedDocument.toElem
  }

  private def getCrypto: Merlin = {
    val properties = new Properties()
    properties.setProperty("org.apache.wss4j.crypto.provider", "class org.apache.ws.security.components.crypto.Merlin")
    CryptoFactory.getInstance().asInstanceOf[Merlin]
  }
}
</code></pre>
<p>Wss4j is a library that maintains an internal state during a signing process, but to avoid confusion it can be summarized as:</p>
<ol>
<li><code>WSSecHeader</code> wraps around the document to be signed</li>
<li>the WSSecHeader instance <code>header</code> will be used as part of the <code>WSSecSignature</code>-Builder</li>
<li>the WSSecSignature instance <code>builder</code> gets configured with all necessary information, which algorithms are used for signing, digesting, canonicalization, which key identifier should be included. Those settings an vary from webservice to webservice.</li>
</ol>
<p>The actual signing of the document, which is now nested like a matryoshka doll, is happening with the help of an instance of <code>Crypto</code>. <code>Crypto</code> will contain either a keystore or a truststore or even both. It needs to be specified in the <code>crypto.properties</code> file or a runtime which class of Crypto will be used.
The most common one is <a href="https://ws.apache.org/wss4j/apidocs/org/apache/wss4j/common/crypto/Merlin.html"><code>Merlin</code></a>.
We have decided to specify its configuration during runtime, since it is more visible than a properties file. Nevertheless, the <code>crypto.properties</code>-file needs to exist in your <code>resources</code> folder neverthless otherwise you will get a following <code>WSSecurityException</code>:</p>
<pre><code class="language-java">  org.apache.wss4j.common.ext.WSSecurityException: No message with ID "resourceNotFound" found in resource bundle "org/apache/xml/security/resource/xmlsecurity"
  [... rest of stacktrace ...]
  Cause: java.nio.file.NoSuchFileException: crypto.properties
</code></pre>
<p>And that's it! The <code>KeyStoreBuilder</code> helps us to load a <code>SigningCertificate</code> and the <code>SigningService</code> uses this loaded certificate to sign SOAP messages.
A receiver of our SOAP message has all the necessary information in our signature to verify that this message has not been tampered with and we are the original sender.</p>
<p>This verification is something we should also do on our side for incoming messages. So let's take a look at how we can verify the signature of received messages.</p>
<h2>Verification of SOAP messages</h2>
<p>Verifying the signature of incoming messages is equally important to ensure that the connection is secure. A verification process will tell you if the message is coming from a trusted source and has not been tampered with.</p>
<p>As previously mentioned we need our source of truth, a pool of trusted public keys from all parties which will receive our SOAP messages. These build the basis of the trust store.</p>
<p>We will create a <code>TrustedCertificates</code> wrapper class in which we will load in the trust store and add this method to the <code>KeyStoreBuilder</code>.</p>
<pre><code class="language-scala">case class TrustedCertificates(keyStore: KeyStore)

object KeyStoreBuilder {

    def loadTrustedCertificate(certificates: Seq[File]): TrustedCertificates = {
    val ks = KeyStore.getInstance(KeyStore.getDefaultType)
    // we just want the keystore to act as a truststore (only containing trusted certificates), so we initialize it empty
    ks.load(null, null)
    val cf = CertificateFactory.getInstance("X.509")
    certificates.foreach { file =>
      CloseableUtil.using(getClass.getResourceAsStream(file.getPath)) { fis =>
        val certPath = cf.generateCertPath(fis, "PKCS7")
        certPath.getCertificates.asScala.toList.foreach { certificate =>
          ks.setCertificateEntry(file.getName, certificate)
        }
      }
    }
    TrustedCertificates(ks)
  }
}
</code></pre>
<p>This trust store is under the hood also just a KeyStore, without containing a private key that requires a password, that's why we can initialize the KeyStore with <code>null</code>-parameters.</p>
<p>Now, the SigningService needs to be extended with this trusted certificates and a <code>verifySignatureOf</code>-method:</p>
<pre><code class="language-scala">import java.io.StringReader
import java.util.Properties
import javax.xml.parsers.DocumentBuilderFactory

import org.apache.wss4j.common.crypto.{ CryptoFactory, Merlin }
import org.apache.wss4j.dom.engine.WSSecurityEngine
import org.xml.sax.InputSource

import scala.util.{Failure, Success, Try}
import scala.xml.Elem

class SigningService(signingCertificate: SigningCertificate, trustedCertificates: TrustedCertificates) {

    private val engine = new WSSecurityEngine()
    private val documentBuilderFactory = DocumentBuilderFactory.newInstance()
    private val crypto: Merlin = getCrypto

    crypto.setKeyStore(signingCertificate.keyStore)
    crypto.setTrustStore(trustedCertificates.keyStore)

    def verifySignatureOf(elem: Elem): Boolean = {
      documentBuilderFactory.setNamespaceAware(true)
      val doc = documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(elem.toString())))

      Try(engine.processSecurityHeader(doc, null, null, crypto)) match {
        case Success(_) => true
        case Failure(exception) =>
          // replace with proper logging
          println(
            s"Unsuccessful signature verification, it is most likely that the certificate used for signing is not in our Truststore: ${exception.getMessage}")
          false
      }
  }

  private def getCrypto: Merlin = {
    val properties = new Properties()
    properties.setProperty("org.apache.wss4j.crypto.provider", "class org.apache.ws.security.components.crypto.Merlin")
    CryptoFactory.getInstance().asInstanceOf[Merlin]
  }
}
</code></pre>
<p>And with that, we have completed our roundtrip of signing and verifying SOAP messages!</p>
<p>Here are gists, articles, and documentation that inspired and helped us to figure out the signing and verification process for our SOAP client. Feel free to check them out!</p>
<hr>
<h3>Sources</h3>
<p><a href="https://gist.github.com/luiswolff/1d388ec8c1d63cfb58974a6f826bc1be">WSSecurityVerifier by Luis Wolff</a></p>
<p><a href="https://gist.github.com/luiswolff/64d15a99fbb5ec4b4e90eec04b09e053">WSSecuritySigner by Luis Wolff</a></p>
<p><a href="https://github.com/apache/ws-wss4j/blob/master/ws-security-dom/src/test/java/org/apache/wss4j/dom/message/SignatureTest.java">Unit Tests from ws-wss4j</a></p>
<p><a href="https://www.xml.com/pub/a/2001/08/08/xmldsig.html">An Introduction to XML Digital Signatures</a></p>
<p><a href="https://stackify.com/soap-vs-rest/">SOAP vs. REST</a></p></div></div></main></section></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/blogs/soap-scala";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-9297e683e8587f367349.js"],"app":["/app-5a3b9f28dce8d9576e87.js"],"component---src-pages-404-js":["/component---src-pages-404-js-110c7577deca45063a75.js"],"component---src-pages-blogs-js":["/component---src-pages-blogs-js-6c7c95f8bc619c7c0c14.js"],"component---src-pages-index-js":["/component---src-pages-index-js-49045172dbc4fabae8e1.js"],"component---src-pages-miniblogs-js":["/component---src-pages-miniblogs-js-0d2471482aa8f6d492a5.js"],"component---src-templates-blogpost-js":["/component---src-templates-blogpost-js-e6c6f3700da185d46b96.js"]};/*]]>*/</script><script src="/blog/polyfill-9297e683e8587f367349.js" nomodule=""></script><script src="/blog/component---src-templates-blogpost-js-e6c6f3700da185d46b96.js" async=""></script><script src="/blog/d6b98378c7c9fb883b2e4a693ed9d6d5ccb6f59a-6da77f1d98d40fd3e3b1.js" async=""></script><script src="/blog/commons-f5cb3665821437b6632f.js" async=""></script><script src="/blog/app-5a3b9f28dce8d9576e87.js" async=""></script><script src="/blog/framework-dbb71ad78d33dc3746f8.js" async=""></script><script src="/blog/webpack-runtime-c2cbaca12af7750641c8.js" async=""></script></body></html>